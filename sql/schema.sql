-- Enable PostGIS for geometry columns where needed
CREATE EXTENSION IF NOT EXISTS postgis;

-- resale_transactions
CREATE TABLE IF NOT EXISTS resale_transactions (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    month TEXT NOT NULL,
    town TEXT NOT NULL,
    flat_type TEXT NOT NULL,
    block TEXT NOT NULL,
    street_name TEXT NOT NULL,
    postal_code_key_id INTEGER NULL REFERENCES postal_codes(id) ON UPDATE CASCADE ON DELETE SET NULL,
    storey_range TEXT NOT NULL,
    floor_area_sqm NUMERIC NOT NULL,
    flat_model TEXT NOT NULL,
    lease_commence_date INTEGER NOT NULL,
    remaining_lease TEXT NOT NULL,
    resale_price NUMERIC NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_resale_transactions_town_ci ON resale_transactions (LOWER(town));
CREATE INDEX IF NOT EXISTS idx_resale_transactions_block_ci ON resale_transactions (LOWER(block));
CREATE INDEX IF NOT EXISTS idx_resale_transactions_flat_type_ci ON resale_transactions (LOWER(flat_type));
CREATE INDEX IF NOT EXISTS idx_resale_transactions_resale_price ON resale_transactions (resale_price);
CREATE INDEX IF NOT EXISTS idx_resale_transactions_postal_fk ON resale_transactions (postal_code_key_id);

-- postal_codes
CREATE TABLE IF NOT EXISTS postal_codes (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    block TEXT NOT NULL,
    street_name TEXT NOT NULL,
    postal_code TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_postal_codes_block_ci ON postal_codes (LOWER(block));
CREATE INDEX IF NOT EXISTS idx_postal_codes_street_ci ON postal_codes (LOWER(street_name));
CREATE INDEX IF NOT EXISTS idx_postal_codes_postal_code ON postal_codes (postal_code);

-- building_polygons
-- Stores building footprint geometry and optional FK to postal_codes
CREATE TABLE IF NOT EXISTS building_polygons (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    block TEXT NOT NULL,
    postal_code TEXT NOT NULL,
    postal_code_key_id INTEGER NULL REFERENCES postal_codes(id) ON UPDATE CASCADE ON DELETE SET NULL,
    building_polygon geometry(Polygon, 4326) NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_building_polygons_block_ci ON building_polygons (LOWER(block));
CREATE INDEX IF NOT EXISTS idx_building_polygons_postal_code ON building_polygons (postal_code);
CREATE INDEX IF NOT EXISTS idx_building_polygons_geom ON building_polygons USING GIST (building_polygon);

-- rail_stations (renamed from mrt_stations)
CREATE TABLE IF NOT EXISTS rail_stations (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    ground_level TEXT NOT NULL,
    building_polygon geometry(Polygon, 4326) NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_rail_stations_name_ci ON rail_stations (LOWER(name));
CREATE INDEX IF NOT EXISTS idx_rail_stations_ground_level_ci ON rail_stations (LOWER(ground_level));
CREATE INDEX IF NOT EXISTS idx_rail_stations_geom ON rail_stations USING GIST (building_polygon);

-- Rail lines (renamed from mrt_lines)
CREATE TABLE IF NOT EXISTS rail_lines (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    abbreviation TEXT NOT NULL UNIQUE,
    rail_type TEXT NOT NULL,
    colour TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS rail_stations_lines (
    mrt_station_id INTEGER NOT NULL REFERENCES rail_stations(id) ON DELETE CASCADE,
    line_id INTEGER NOT NULL REFERENCES rail_lines(id) ON DELETE CASCADE,
    PRIMARY KEY (mrt_station_id, line_id)
);

-- Registry of data tables (logical tables managed by this API)
CREATE TABLE IF NOT EXISTS data_tables (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);

CREATE INDEX IF NOT EXISTS idx_data_tables_name_ci ON data_tables (LOWER(name));

-- Table metadata per logical table (not per row)
CREATE TABLE IF NOT EXISTS table_metadata (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_id INTEGER NOT NULL REFERENCES data_tables(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (table_id)
);

-- Trigger to auto-update updated_at on any update (defensive; touch endpoint also sets it)
CREATE OR REPLACE FUNCTION trg_set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS set_updated_at_trigger ON table_metadata;
CREATE TRIGGER set_updated_at_trigger
BEFORE UPDATE ON table_metadata
FOR EACH ROW EXECUTE FUNCTION trg_set_updated_at();
